package main

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"log"
	"path/filepath"
)

type stepImplGenerator struct {
	buf       bytes.Buffer
	stepPkg   string
	outPkg    string
	stepImpls []stepImpl
}

func (g *stepImplGenerator) write(format string, args ...interface{}) {
	fmt.Fprintf(&g.buf, format, args...)
}

func (g *stepImplGenerator) writeln(format string, args ...interface{}) {
	g.write(format+"\n", args...)
}

func (g *stepImplGenerator) generate() {

	g.writeln("// GENERATED BY ELICIT - DO NOT EDIT\n")

	pkgName := filepath.Base(g.outPkg)
	g.writeln("package %s", pkgName)

	g.writeln("import (")
	g.writeln("%q", "mmatt/elicit")
	g.writeln("steps %q", g.stepPkg)
	g.writeln(")")

	g.writeln("func init() {")
	g.writeln("e := elicit.CurrentContext\n")

	for _, s := range g.stepImpls {
		g.writeln("e.RegisterStep(%q, steps.%s)", s.pattern, s.fn)
	}

	g.writeln("}")

	g.writeStepsFile()
}

func (g *stepImplGenerator) writeStepsFile() {
	outname := "elicit_steps_test.go"
	outpath := filepath.Join(g.outPkg, outname)

	src := formatSource(g.buf.Bytes())

	if err := ioutil.WriteFile(outpath, src, 0644); err != nil {
		log.Fatalf("writing output to %q: %s", outpath, err)
	}
}
